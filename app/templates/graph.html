<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v5.min.js"></script>:
<style>

path.link {
  fill: none;
  stroke: #666;
  stroke-width: 1.5px;
}



text {
  fill: #000;
  font: 10px sans-serif;
  pointer-events: none;
}


</style>
<body>
<script>
 // circle {
  
//  stroke: #fff;
//  stroke: black;
//  stroke-width: 1.5px;
//fill: #ccc;
//}

// get the data
links =  [
  {
    "source": "Milwaukee Bucks",
    "target": "Cleveland Cavaliers",
    "value": 0
  },
  {
    "source": "Milwaukee Bucks",
    "target": "Sacramento Kings",
    "value": 0
  },
  {
    "source": "Detroit Pistons",
    "target": "Philadelphia 76ers",
    "value": 1
  },
  {
    "source": "Cleveland Cavaliers",
    "target": "Los Angeles Lakers",
    "value": 1
  },
  {
    "source": "Dallas Mavericks",
    "target": "Houston Rockets",
    "value": 1
  },
  {
    "source": "Miami Heat",
    "target": "San Antonio Spurs",
    "value": 1
  },
  {
    "source": "Miami Heat",
    "target": "Los Angeles Lakers",
    "value": 1
  },
  {
    "source": "Brooklyn Nets",
    "target": "Los Angeles Lakers",
    "value": 1
  },
  {
    "source": "Brooklyn Nets",
    "target": "Houston Rockets",
    "value": 1
  },
  {
    "source": "Sacramento Kings",
    "target": "Los Angeles Lakers",
    "value": 1
  },
  {
    "source": "Houston Rockets",
    "target": "Golden State Warriors",
    "value": 0
  },
  {
    "source": "Los Angeles Lakers",
    "target": "Los Angeles Clippers",
    "value": 1
  },
  {
    "source": "Sacramento Kings",
    "target": "Philadelphia 76ers",
    "value": 1
  },
  {
    "source": "San Antonio Spurs",
    "target": "Miami Heat",
    "value": 0
  },
  {
    "source": "Portand Trail Blazers",
    "target": "Miami Heat",
    "value": 0
  },
  {
    "source": "Chicago Bulls",
    "target": "Boston Celtics",
    "value": 0
  },
  {
    "source": "New York Knicks",
    "target": "Golden State Warriors",
    "value": 0
  },
  {
    "source": "Denver Nuggets",
    "target": "Golden State Warriors",
    "value": 0
  },
  {
    "source": "Portand Trail Blazers",
    "target": "Golden State Warriors",
    "value": 0
  },
  {
    "source": "New York Knicks",
    "target": "Denver Nuggets",
    "value": 1
  },
  {
    "source": "San Antonio Spurs",
    "target": "Denver Nuggets",
    "value": 0
  },
  {
    "source": "Houston Rockets",
    "target": "Denver Nuggets",
    "value": 1
  },
  {
    "source": "Portand Trail Blazers",
    "target": "San Antonio Spurs",
    "value": 1
  },
  {
    "source": "Houston Rockets",
    "target": "Brooklyn Nets",
    "value": 0
  },
  {
    "source": "Milwaukee Bucks",
    "target": "Boston Celtics",
    "value": 0
  },
  {
    "source": "Golden State Warriors",
    "target": "Milwaukee Bucks",
    "value": 1
  },
  {
    "source": "Golden State Warriors",
    "target": "Atlanta Hawks",
    "value": 1
  },
  {
    "source": "Orlando Magic",
    "target": "Memphis Grizzlies",
    "value": 0
  },
  {
    "source": "Washington Wizards",
    "target": "New York Knicks",
    "value": 1
  },
  {
    "source": "Boston Celtics",
    "target": "Orlando Magic",
    "value": 1
  },
  {
    "source": "Oklahoma City Thunder",
    "target": "Sacramento Kings",
    "value": 0
  },
  {
    "source": "Boston Celtics",
    "target": "Charlotte Hornets",
    "value": 1
  },
  {
    "source": "Boston Celtics",
    "target": "Philadelphia 76ers",
    "value": 1
  },
  {
    "source": "Brooklyn Nets",
    "target": "Miami Heat",
    "value": 1
  },
  {
    "source": "Indiana Pacers",
    "target": "Chicago Bulls",
    "value": 1
  },
  {
    "source": "New York Knicks",
    "target": "Boston Celtics",
    "value": 0
  },
  {
    "source": "Los Angeles Lakers",
    "target": "Phoenix Suns",
    "value": 0
  },
  {
    "source": "Golden State Warriors",
    "target": "Dallas Mavericks",
    "value": 1
  },
  {
    "source": "New Orleans Pelicans",
    "target": "Indiana Pacers",
    "value": 0
  },
  {
    "source": "Milwaukee Bucks",
    "target": "Brooklyn Nets",
    "value": 0
  },
  {
    "source": "Washington Wizards",
    "target": "Portand Trail Blazers",
    "value": 1
  },
  {
    "source": "Utah Jazz",
    "target": "Golden State Warriors",
    "value": 1
  },
  {
    "source": "Boston Celtics",
    "target": "Utah Jazz",
    "value": 1
  },
  {
    "source": "Golden State Warriors",
    "target": "Charlotte Hornets",
    "value": 1
  },
  {
    "source": "Boston Celtics",
    "target": "Atlanta Hawks",
    "value": 1
  },
  {
    "source": "Philadelphia 76ers",
    "target": "Boston Celtics",
    "value": 0
  }
];

var nodes = {};

// compute the distinct nodes from the links.
links.forEach(function(link) {
    link.source = nodes[link.source] ||
        (nodes[link.source] = {name: link.source});
    link.target = nodes[link.target] ||
        (nodes[link.target] = {name: link.target});
});


var margin = {top: 30, right: 30, bottom: 70, left: 90};


var width = 950 - margin.left - margin.right;
var height = 700 - margin.top - margin.bottom;

var force = d3.forceSimulation()
    .nodes(d3.values(nodes))
    .force("link", d3.forceLink(links).distance(100))
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force("x", d3.forceX())
    .force("y", d3.forceY())
    .force("charge", d3.forceManyBody().strength(-250))
    .alphaTarget(1)
    .on("tick", tick);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);
    
g1 = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

nomre = g1.append("text")
    .attr("x", (width - 150))             
    .attr("y", (margin.bottom / 10))
    .attr("text-anchor", "center")  
    .style("font-size", "12px")
    .style("stroke", "black")
    .attr("stroke-width", 1)  
    .text({{ gtid }} );
//svg.select("body")
//          .append("text")
 //         .attr("x", 0)             
//          .attr("y", 0)
//          .attr("text-anchor", "center")  
//          .style("font-size", "13px")  
//          .text("oansari3");



//q2b: If the value of the edge is equal to 0, the edge should be blue, thick, and solid.
//If the value of the edge is equal to 1, the edge should be black, thin, and dashed.

// add the links and the arrows
var path = g1.append("g")
    .selectAll("path")
    .data(links)
    .enter()
    .append("path")
    //.attr("class", function(d) { return "link " + d.type; })
    .attr("class", "link")
    //.style('stroke', 'red') // q2b code
    .style('stroke', function(d) {
      if (d.value == 0) {
        return ('blue');
      } else {
        return ('black')
      }
    }) // q2b code
    //.attr('stroke-width', 5);
    .attr('stroke-dasharray', function(d) {
      if (d.value == 1) {
        return '3, 3'; // l of dash and l of spaces bw dash
      } else {
        return null // for solid line
      } 
    })
    .attr('stroke-width', function(d) {
      if (d.value ==0) {
        return 20;
      } else {
        return 2;
      }
    });






// define the nodes
var node = g1.selectAll(".node")
    .data(force.nodes())
    .enter().append("g")
    .attr("class", "node")
    .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended))
        .on("dblclick", dblclick); //   q2d1

// add the nodes
// q2c1    [1.5 points] Scale the radius of each node in the graph based on the degree of the node (you may try linear or squared scale, but you are not limited to these choices). 
// q2c2    [1.5 points] The degree of each node should be represented by varying colors. Pick a meaningful color scheme (hint: color gradients). The number of color gradations is up to you, but it must be visually evident that the nodes with higher degree use darker/deeper colors and the nodes with lower degrees use lighter colors. You can find example color gradients at Color Brewer.
var weights = []; //q2c2
//var colors = d3.scaleOrdinal().range(d3.schemeGreens); // q2c2
//var colors = d3.scaleOrdinal().range(["#e5f5f9", "#99d8c9", "#2ca25f"]); // q2c2
// taken from http://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3



// myScale;
var colorScale;
var color1;


node.append("circle") //q2c1
    .attr("r", function(d) {
      d.weight = path.filter(function(x) {
        return x.source.index == d.index || x.target.index == d.index
        }).size();
      weights.push(d.weight); // for q2c2
      var minR = 3;
      return minR + (d.weight)*3;
    })
    //.style("fill", d3.color("blue"));
    .style("fill", function(d) {
      //myScale = d3.scaleLinear();
      //myScale
      //.domain([d3.min(weights), d3.max(weights)])
      //.range([0,100]);
      //colorScale = d3.scaleSequential(d3.interpolateRdYlGn)
      //              .domain([d3.min(weights), d3.max(weights)]);
      color1 = d3.scaleLinear()
        .domain([d3.min(weights), d3.max(weights)])
        .range(['#e5f5e0', '#31a354'])
        .interpolate(d3.interpolateHcl);
      //return colorScale(d.weight);
      return color1(d.weight);

      //return "#00dfc9";
    });
   
    




// add the curvy lines
function tick() {
    path.attr("d", function(d) {
        var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy);
        return "M" +
            d.source.x + "," +
            d.source.y + "A" +
            dr + "," + dr + " 0 0,1 " +
            d.target.x + "," +
            d.target.y;
    });

    node
        .attr("transform", function(d) {
        return "translate(" + d.x + "," + d.y + ")"; });

        // q2a new code
    text.attr("transform", function(d) {
      return "translate(" + d.x + "," + d.y + ")";
    });
};


// q2a new code:
var text = g1.append("g").selectAll("text")
  .data(force.nodes())
  .enter().append("text")
  .attr("x", ".40em")
  .attr("y", 12)
  .text(function(d) {
    return d.name;
  });




// q2d1 [2 points] Modify the code so that when you double click on a node, it pins the node’s position such that it will not be modified by the graph layout algorithm (note: pinned nodes can still be dragged around by the user but they will remain at their positions otherwise).

function dblclick(d) {
  sel = d3.select(this);
  //console.log(d.name, " was double clicked")
  
  if (d.fixed == "undefined") d.fixed = false;
  var state = d.fixed;

  //flip fixed to unfixed or vice versa when dblclick() is called
  state = !state;

  if (state) { // a free node is double clicked to fix it 
    sel.classed("fixed",  d.fixed = true);
    d.fx = d.x;
    d.fy = d.y;


    sel.selectAll("circle")
      .style("stroke", "black") //q2d2 Mark pinned nodes to visually distinguish them from unpinned nodes, 
      .attr("stroke-width", 3) // q2d2
    //console.log("sel class is " , sel);
    //dragged(d);

  } else { //q2d3: Double clicking a pinned node should unpin (unfreeze) its position and unmark it.
    sel.classed("fixed",  d.fixed = false);
    sel.selectAll("circle")
      .style("stroke", "white") // q2d2
      .attr("stroke-width", 0)// q2d2
    //console.log("fixed item dbl clicked to be released!")
    d.fx = null;
    d.fy = null;


  }
//  stroke: black;
//  stroke-width: 1.5px;
  
};

//function dblclick(d) {
//  d3.select(this).classed("fixed", d.fixed = function(d) {
//   if (d.fixed == true) {
//   return false; 
//    } else {
//      return true;
//    }
//  })
//};

function dragstarted(d) {
    if (!d3.event.active) force.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
};

function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
};

function dragended(d) {
    if (!d3.event.active) force.alphaTarget(0);
    if (d.fixed == true) {
        d.fx = d.x;
        d.fy = d.y;
    }
    else {
        d.fx = null;
        d.fy = null;
    }
};

</script>
</body>
</html>
