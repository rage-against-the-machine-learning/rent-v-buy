# this script takes the clean dataset gets the data for the current month
# Created by Skye
import numpy as np
import pandas as pd

from matplotlib import pyplot as plt
from fbprophet import Prophet
from sklearn.metrics import mean_squared_error, mean_absolute_error

from datetime import datetime
from dateutil.parser import parse
from dateutil import relativedelta

import json
    

# number of months between two dates
def find_pred_size (df:pd.DataFrame) -> int:
    '''
    purpose: calculate the number of months b/t the most recent time series data point
    and present day
    :df: pandas DataFrame holding teh time series for a specific zip code
    :output: months (integer)
    '''
    assert 'ds' in df.columns, "'ds' column needs to be in the input DataFrame"
    today = datetime.now()
    r = relativedelta.relativedelta(today, df['ds'].max())
    years = r.years
    months = r.months
    return int((years * 12) + months)


#do we want to rent or buy
def make_model_input_df (data:pd.DataFrame, rent_or_buy:str, zip_code_of_interest:int) -> pd.DataFrame:
    '''
    :data: the entire dataframe generated by the california_only.py script
    :rent_or_buy: input string to specify which of the two prediciton values to forecast
    :zip_code_of_interest: 5 digit integer
    :returns: a DataFrame ready to input into fbprophet for time series forecasting
    '''
    # TODO: Write code to handle zip codes that we are not generating predictions for
    assert len(zip_code_of_interest) == 5, 'typo in the input, must be a 5-digit integer'

    #based on the input which column do we want to look at
    # we will do both as long as data is present for each zip code
    if rent_or_buy == 'rent':   
        model_payload = data.rename(columns={ 'Zri_MultiFamilyResidenceRental': 'y'})
    else:
        model_payload = data.rename(columns={'ZHVI_SingleFamilyResidence': 'y'})
        
    return model_payload


#actual prediction model
def find_value_today(model_payload:pd.DataFrame, prediction_size:int) -> (float, pd.DataFrame):
    '''
    purpose: generate a predicted value based on the specified rent or buy input 
    :model_payload: DataFrame already filtered on a zipcode w/ either rent or buy specified 
    :prediction_size: the number of periods (in months) between the last actual data point time and today
    :output: returns a tuple (forecasted rent or buy value, DataFrame with underlying time series Trend)
    '''
    # TODO: build a checker to ensure the zip code is no tone of the ones we've ruled out
    try:
        my_model = Prophet(interval_width=0.95, 
                           yearly_seasonality= 3, 
                           weekly_seasonality=False, 
                           daily_seasonality=False)
        
        my_model.fit(model_payload)

        future = my_model.make_future_dataframe(periods=prediction_size, freq='M')
        # make a predictions DataFrame
        forecast = my_model.predict(future)
        # my_forcast_data = forecast[['ds', 'yhat']] <-- this is unreachable code 

        # Collect the last projected value (today's value)
        value_today = forecast['yhat'].iloc[-1]
        appr_data = forecast["trend"]

    except:
        value_today = 0

    return value_today, appr_data


def calc_appr_rate(appr_data:pd.DataFrame):
    '''
    purpose: this function looks back to the most recent 3 year appreciation trends
    and calculates the Compound Annual Growth Rate
    :appr_data: trend data generated from Facebook Prophet when the predictions were generated
    '''
    # Use indices to get the most recent 3 years
    old_value = appr_data.iloc[-37]
    new_value = appr_data.iloc[-1]

    # Calculate CAGR
    cagr = (new_value / old_value)**(1/3) - 1
    return round(cagr * 100, 2)
    

def make_main(my_data:pd.DataFrame, zip_code_of_interest:int) -> dict():
    '''
    '''
    #for each zipcode
    clean_data = my_data.loc[my_data['ZipCode'] == zip_code_of_interest]
    
    #change date column to the correct format
    prediction_size_rent = find_pred_size(clean_data)
    prediction_size_buy  = find_pred_size(clean_data)
    
    #zipcode we want data for
    # #need to check if region name is always the same...
    rent_dataset = interest_dataset(clean_data, 'rent', zip_code_of_interest)
    buy_dataset  = interest_dataset(clean_data, 'buy', zip_code_of_interest)
   
    #predict
    rent_value, appr_data_rent = find_value_today(rent_dataset, prediction_size_rent)
    #print(rent_value)
    buy_value, appr_data_buy  = find_value_today(buy_dataset, prediction_size_buy)
    #print(buy_value)
    
    #appreciation rate
    appr_rate_buy = cal_appre_rate(buy_dataset, appr_data_buy)
    
    #round values
    rent_value = int(rent_value)
    buy_value = round(buy_value/1000, 1)
    
    return {str(zip_code_of_interest): {"buy": f'${buy_value:,}k', "rent": f'${rent_value:,}/month', "appr_rate" : f'{appr_rate_buy}%'}}

    