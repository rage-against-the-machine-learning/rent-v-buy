# This script takes the clean dataset and generates predictions

import pandas as pd

from matplotlib import pyplot as plt
from fbprophet import Prophet
import warnings
warnings.filterwarnings('ignore')

from datetime import datetime
from dateutil import relativedelta

import json
import pickle

import pathlib
import sys
import os 
sys.path.append(str(pathlib.Path().absolute().parent))
    

# number of months between two dates
def find_pred_size (df:pd.DataFrame) -> int:
    '''
    purpose: calculate the number of months b/t the most recent time series data point
    and present day
    :df: pandas DataFrame holding teh time series for a specific zip code
    :output: months (integer)
    '''
    assert 'ds' in df.columns, "'ds' column needs to be in the input DataFrame"
    today = datetime.now()
    r = relativedelta.relativedelta(today, df['ds'].max())
    years = r.years
    months = r.months

    return int((years * 12) + months)


#do we want to rent or buy
def make_model_input_df (data:pd.DataFrame, rent_or_buy:str) -> pd.DataFrame:
    '''
    :data: the entire dataframe generated by the california_only.py script
    :rent_or_buy: input string to specify which of the two prediciton values to forecast
    :zip_code_of_interest: 5 digit integer
    :returns: a DataFrame ready to input into fbprophet for time series forecasting'''

    #based on the input which column do we want to look at
    # we will do both as long as data is present for each zip code
    if rent_or_buy == 'rent':   
        model_payload = data.rename(columns={ 'Zri_MultiFamilyResidenceRental': 'y'})
    else:
        model_payload = data.rename(columns={'ZHVI_SingleFamilyResidence': 'y'})
        
    return model_payload


#actual prediction model
def find_value_today(model_payload:pd.DataFrame, prediction_size:int) -> (float, pd.DataFrame):
    '''
    purpose: generate a predicted value based on the specified rent or buy input 
    :model_payload: DataFrame already filtered on a zipcode w/ either rent or buy specified 
    :prediction_size: the number of periods (in months) between the last actual data point time and today
    :output: returns a tuple (forecasted rent or buy value, DataFrame with underlying time series Trend)
    '''

    try:
        my_model = Prophet(interval_width=0.95, 
                           yearly_seasonality= 3, 
                           weekly_seasonality=False, 
                           daily_seasonality=False)
        
        my_model.fit(model_payload)

        future = my_model.make_future_dataframe(periods=prediction_size, freq='M')
        # make a predictions DataFrame
        forecast = my_model.predict(future)
        # my_forcast_data = forecast[['ds', 'yhat']] <-- this is unreachable code 

        # Collect the last projected value (today's value)
        value_today = forecast['yhat'].iloc[-1]
        appr_data = forecast["trend"]
        return value_today, appr_data

    except:
        value_today = 0
        return value_today, None


def calc_appr_rate(appr_data:pd.DataFrame):
    '''
    purpose: this function looks back to the most recent 3 year appreciation trends
    and calculates the Compound Annual Growth Rate
    :appr_data: trend data generated from Facebook Prophet when the predictions were generated
    '''
    # Use indices to get the most recent 3 years
    old_value = appr_data.iloc[-37]
    new_value = appr_data.iloc[-1]

    # Calculate CAGR
    cagr = (new_value / old_value)**(1/3) - 1
    return round(cagr * 100, 2)
    

def make_UI_n_dec_calculator_outputs (my_data:pd.DataFrame, zip_code_of_interest:int, excl_zips:list) -> (dict, dict):
    '''
    Given a zipcode, 
    1. Filter all time series data for that zip code
    2. Determine the prediction size
    3. Create sub dataframes each for rent and buy (as payloads for prediction)
    4. Generate predictions using FB Prophet for each rent & buy
    5. Use the respective trend data for rent & buy to calculate CAGR (appreciation rates)

    :my_data: preprocessed data generated by california_only.py script
    :zipcode_of_interest: 5 digit integer for the zipcode specified
    :excl_zips: list of zip codes for which there is not sufficient information
    '''
    assert len(str(zip_code_of_interest)) == 5

    if zip_code_of_interest not in excl_zips:

        # For each zipcode
        clean_data = my_data.loc[my_data['ZipCode'] == zip_code_of_interest]
        clean_data.reset_index(drop=True, inplace=True)
        
        # prepare the dataframe for payload to model
        rent_dataset = make_model_input_df(clean_data, 'rent')
        buy_dataset  = make_model_input_df(clean_data, 'buy')
        
        # Determine the number of months for which to forecast
        prediction_size_rent = find_pred_size(rent_dataset)
        prediction_size_buy  = find_pred_size(buy_dataset) 
        
        # Predict rent & buy values, keep trend data for home value trends
        rent_value, _ = find_value_today(rent_dataset, prediction_size_rent) # we don't need appr rates for rentals
        buy_value, appr_data_buy  = find_value_today(buy_dataset, prediction_size_buy)
        
        # Calculate the appreciation rate
        appr_rate_buy = calc_appr_rate(appr_data_buy)
        
        # Round values for UI output; exclude cents in rental values, express buy values in thousands
        rent_value = int(rent_value) 
        buy_value = round(buy_value/1000, 1) 

        UI_formatted = {str(zip_code_of_interest): {"buy": f'${buy_value:,}K', 
                                                    "rent": f'${rent_value:,}/month', 
                                                    "appr_rate" : f'{appr_rate_buy}%'}}

        rentVbuy_formatted = {str(zip_code_of_interest): {"buy": buy_value, 
                                                        "rent": rent_value, 
                                                        "appr_rate" : appr_rate_buy }}

    else:
        UI_formatted = {str(zip_code_of_interest): {"buy": '$ N/A', 
                                                    "rent": '$ N/A', 
                                                    "appr_rate" : 'N/A %'}}

        rentVbuy_formatted = {str(zip_code_of_interest): {"buy": 0, 
                                                          "rent": 0, 
                                                          "appr_rate" : 0 }}

    return UI_formatted, rentVbuy_formatted

    
# 1. BRING IN THE PREPROCESSED DATA & skip-zip codes
processed = pd.read_pickle('../data/processed/interpolated_fillnaTime_df.pickle')

my_file = open ('../data/processed/exclude_these_zips.pickle', 'rb')
excl_zips = pickle.load(my_file)


# 2. Get all unizue zipcodes & iterate over them to create outputs:
all_ca_zips = processed['ZipCode'].unique().tolist()

UI_output = dict()
calculator_output = dict()

for zipcode in all_ca_zips:
        UI, calculator = make_UI_n_dec_calculator_outputs (processed, zipcode, excl_zips)
        UI_output.update(UI)
        calculator_output.update(calculator)

with open('../data/predictions/UI_output.json', 'w') as f1:
    json.dump(UI_output, f1)

with open('../data/predictions/calculator_output.json', 'w') as f2:
    json.dump(calculator_output, f2)